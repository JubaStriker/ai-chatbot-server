import mongoose from 'mongoose';
import paginate from 'mongoose-paginate';
import mongooseAggregatePaginate from 'mongoose-aggregate-paginate';

const Schema = new mongoose.Schema({
    orderId: {
        type: String, index: true, unique: true, required: true,
    },
    pmsId: String,
    type: {
        type: String,
        enum: ['payin', 'payout', 'fiat_payout', 'crypto_payout', "collections", "fiat_to_fiat_prefund", "crypto_to_crypto_prefund"],
    },
    fiatTicker: String,
    mid: String,
    cryptoTicker: String,
    fiatAmount: Number,
    email: String,
    cryptoAmount: Number,
    cryptoUnitPrice: Number,
    depositCurrency: String,
    depositAmount: Number,
    depositNetwork: String,
    withdrawCurrency: String,
    withdrawAmount: Number,
    totalFee: Number,
    conversionRate: Number,
    quoteId: String,
    preAccId: String,
    fees: {
        networkFee: Number,
        processingFee: Number,
        fixedFee: Object,
    },
    customer: Object,
    fiat: {
        orderId: String,
        partnerFee: String,
        tfFee: String,
        tfFeeRate: String,
        cxFee: String,
        cxFeeRate: String,
        processingFee: String,
        processingFeeMode: String,
        processingFeeRate: String,
        discount: String,
        discountRate: String,
        xeRate: String,
        conversionRate: String,
        conversionRateWithoutMarkup: String,
        orderAmount: Number,
        netAmount: String,
        exchangeRate: String,
        markupFee: String,
        additionalFees: String,
        rrFee: String,
        rrRate: String,
    },
    status: {
        type: String,
        trim: true,
        enum: ['approval_pending', 'draft', 'initiated', 'fund_processing', 'fund_settled', 'fund_failed', 'asset_deposited', 'asset_deposit_failed', 'partial_asset_settled', 'asset_failed', 'asset_settled', 'asset_settle_failed', 'onHold', 'rejected', "completed", "payment_pending", "manual_review"],
    },
    walletAddress: String,
    userCountry: String,
    userId: { type: String },
    orgId: String,
    senderName: {
        firstName: String,
        lastName: String,
    },
    recipientName: {
        firstName: String,
        lastName: String,
    },
    error: Object,
    quoteDetails: Object,
    metaData: {
        bankId: String,
        cryptoName: String,
        fiatName: String,
        paymentUrl: String,
        usdAmount: Number,
        quoteExpireTime: String,
        bankAccNumber: String,
        monitoringResults: Object,
    },
    paymentType: {
        type: String,
        enum: ['card', 'bank', 'local_wallet', 'netbanking', 'local', 'otc', 'qr_code_aggregator', "bank_transfer", "netbanking_aggregator", "crypto_wallet"],
    },
    paymentDetails: Object,
    depositCurrencyDetails: Object,
    withdrawCurrencyDetails: Object,
    userType: {
        type: String,
        enum: ['individual', 'organization'],
    },
    paymentFormattedName: String,
    paymentGateway: String,
    product: String,
    apiKey: String,
    crypto: Object,
    deviceDetails: Object,
    timestamps: Object,
    redirectUrl: String,
    paymentName: String,
    accessToken: String,
    refreshToken: String,
    purposeCode: String,
    actualPaymentCode: String,
    recipientCount: String,
    cryptoPartner: String,
    blockchain: String,
    recipientId: String,
    title: String,
    description: String,
    additionalDetails: {
        notes: String,
        invoiceUrl: String,
    },
    validity: String,
    cxId: String,
    settlementStatus: String,
}, {
    timestamps: true,
    collection: 'orders',
});

Schema.plugin(paginate);
Schema.plugin(mongooseAggregatePaginate);

export const Order = mongoose.nucleus.model('Order', Schema);
